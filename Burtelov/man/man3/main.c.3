.TH "main.c" 3 "Вт 29 Окт 2019" "lab_02_doxygen" \" -*- nroff -*-
.ad l
.nh
.SH NAME
main.c
.SH SYNOPSIS
.br
.PP
\fC#include <stdlib\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br

.SS "Классы"

.in +1c
.ti -1c
.RI "struct \fBcar\fP"
.br
.RI "Структура, предназначенная для обработки данных об автомобилях "
.ti -1c
.RI "struct \fBcar_sort\fP"
.br
.RI "Структура ключей "
.in -1c
.SS "Макросы"

.in +1c
.ti -1c
.RI "#define \fBSTRUCT_LEN\fP   70"
.br
.ti -1c
.RI "#define \fBMENU_LEN\fP   6"
.br
.ti -1c
.RI "#define \fBPOS_LEN\fP   8"
.br
.ti -1c
.RI "#define \fBBUF_LEN\fP   100"
.br
.ti -1c
.RI "#define \fBCHAR_LEN\fP   30"
.br
.ti -1c
.RI "#define \fBAMOUNT_SORT\fP   10000"
.br
.ti -1c
.RI "#define \fBEXIT_FAILURE_DEL\fP   \-1"
.br
.in -1c
.SS "Определения типов"

.in +1c
.ti -1c
.RI "typedef char \fBBUFER\fP[\fBBUF_LEN\fP]"
.br
.ti -1c
.RI "typedef short int \fBPOS_PARS\fP[\fBPOS_LEN\fP]"
.br
.in -1c
.SS "Функции"

.in +1c
.ti -1c
.RI "void \fBcar_hb\fP (\fBcar_sort\fP *s, \fBcar_sort\fP *s_not, int len_struct)"
.br
.RI "Инициализация не отсортированной струкртуры ключей,\&. "
.ti -1c
.RI "void \fBcar_dont_hb\fP (\fBcar\fP *p, \fBcar\fP *p_not, int len_struct)"
.br
.RI "Инициализация исходной не отсортированной структуры "
.ti -1c
.RI "void \fBcar_sort_init_frst\fP (\fBcar_sort\fP *s, \fBcar_sort\fP *s_not, int len_struct)"
.br
.RI "Возращение структуры ключей к не отсортированному виду "
.ti -1c
.RI "void \fBident_struct\fP (\fBcar\fP *p)"
.br
.RI "Идентификайия структуры для дальнейшего заполнения "
.ti -1c
.RI "void \fBident_buf\fP (\fBBUFER\fP buf)"
.br
.RI "Идентификация буфера "
.ti -1c
.RI "void \fBident_pos\fP (\fBPOS_PARS\fP pos_pars)"
.br
.RI "Нахождение позиции запятой, для дальнейшего парсинга строки "
.ti -1c
.RI "void \fBdel_struct_record_menu\fP ()"
.br
.RI "Вывод меню при выборе удаления полей структуры "
.ti -1c
.RI "void \fBprintf_result_sort\fP (\fBcar\fP *p, \fBcar_sort\fP *p_s, int len_struct)"
.br
.RI "Печать ключей "
.ti -1c
.RI "void \fBsort_struct_bubble\fP (\fBcar_sort\fP *s, int len_struct)"
.br
.RI "Сортировка структуры ключей методом пузырька "
.ti -1c
.RI "void \fBsort_struct_quick\fP (\fBcar_sort\fP *s, int len_struct)"
.br
.RI "Сортировка структуры ключей методом Шелла "
.ti -1c
.RI "int \fBdel_struct_search\fP (\fBcar\fP *p, \fBBUFER\fP buf, int record)"
.br
.RI "Функция поиска совпадений в полях структуры при удалении "
.ti -1c
.RI "int \fBdel_struct_record\fP (\fBcar\fP *p, int *len_struct)"
.br
.RI "Удаление полей записи в массиве структур "
.ti -1c
.RI "int \fBappend_struct\fP (\fBcar\fP *p, \fBcar_sort\fP *s, int *len_struct)"
.br
.RI "Добавление новых элементов в массив структур "
.ti -1c
.RI "void \fBprint_len\fP (\fBcar\fP *p, short *len_model, short *len_country, short *len_color, short *len_cost, int len_struct)"
.br
.ti -1c
.RI "void \fBsort_dont_key_bubble\fP (\fBcar\fP *p, int len_struct)"
.br
.RI "Сортировка массива структур методом пузырька "
.ti -1c
.RI "void \fBsort_dont_key_quick\fP (\fBcar\fP *p, int len_struct)"
.br
.RI "Сортировка массива структур методом Шелла "
.ti -1c
.RI "void \fBprint_struct_sort\fP (\fBcar\fP *p, \fBcar_sort\fP *s, int len_struct)"
.br
.RI "Печать таблицы, содержащий поля массива структур "
.ti -1c
.RI "void \fBprint_result\fP (clock_t shell1, clock_t shell2, clock_t bubble1, clock_t bubble2, clock_t shell3, clock_t shell4, clock_t bubble3, clock_t bubble4)"
.br
.RI "Печать времени сортировок массива структур и массива ключей "
.ti -1c
.RI "void \fBprint_struct\fP (\fBcar\fP *p, int len_struct)"
.br
.RI "Печать таблицы данных "
.ti -1c
.RI "int \fBparser\fP (\fBcar\fP *p, \fBcar_sort\fP *s, \fBBUFER\fP buf)"
.br
.RI "Парсинг строк из файла "
.ti -1c
.RI "int \fBmenu\fP (\fBcar\fP *p, \fBcar\fP *p_not, \fBcar_sort\fP *s, \fBcar_sort\fP *o, int *len_struct)"
.br
.RI "Меню "
.ti -1c
.RI "int \fBmain\fP ()"
.br
.in -1c
.SH "Макросы"
.PP 
.SS "#define AMOUNT_SORT   10000"

.PP
\fBАргументы\fP
.RS 4
\fIAMOUNT_SORT\fP кол-во сортировок 
.RE
.PP

.SS "#define BUF_LEN   100"

.PP
\fBАргументы\fP
.RS 4
\fIBUF_LEN\fP максимальный размер буфера 
.RE
.PP

.SS "#define CHAR_LEN   30"

.PP
\fBАргументы\fP
.RS 4
\fICHAR_LEN\fP максимальный размер массива символа 
.RE
.PP

.SS "#define EXIT_FAILURE_DEL   \-1"

.SS "#define MENU_LEN   6"

.PP
\fBАргументы\fP
.RS 4
\fIMENU_LEN\fP количество пунктов в меню 
.RE
.PP

.SS "#define POS_LEN   8"

.PP
\fBАргументы\fP
.RS 4
\fIPOS_LEN\fP количество позиций для дальнейшего парсинга 
.RE
.PP

.SS "#define STRUCT_LEN   70"

.PP
\fBАргументы\fP
.RS 4
\fISTRUCT_LEN\fP макстмальный размер массива структур 
.RE
.PP

.SH "Типы"
.PP 
.SS "typedef char BUFER[\fBBUF_LEN\fP]"

.PP
\fBАргументы\fP
.RS 4
\fIBUFER[BUF_LEN]\fP буфер 
.RE
.PP

.SS "typedef short int POS_PARS[\fBPOS_LEN\fP]"

.PP
\fBАргументы\fP
.RS 4
\fIPOS_PARS[POS_LEN]\fP массив, содержащий позиции запятых для парсинга строки 
.RE
.PP

.SH "Функции"
.PP 
.SS "int append_struct (\fBcar\fP * p, \fBcar_sort\fP * s, int * len_struct)"

.PP
Добавление новых элементов в массив структур 
.SS "void car_dont_hb (\fBcar\fP * p, \fBcar\fP * p_not, int len_struct)"

.PP
Инициализация исходной не отсортированной структуры 
.PP
\fBАргументы\fP
.RS 4
\fI*p\fP - указатель на массив структур-ключей 
.br
\fI*p_not\fP - указатель на не отстортированный массив структур 
.RE
.PP

.SS "void car_hb (\fBcar_sort\fP * s, \fBcar_sort\fP * s_not, int len_struct)"

.PP
Инициализация не отсортированной струкртуры ключей,\&. 
.PP
\fBАргументы\fP
.RS 4
\fI*s\fP - указатель на массив структур-ключей 
.br
\fI*s_not\fP - указатель на не отстортированный массив структур-ключей 
.RE
.PP

.SS "void car_sort_init_frst (\fBcar_sort\fP * s, \fBcar_sort\fP * s_not, int len_struct)"

.PP
Возращение структуры ключей к не отсортированному виду 
.SS "int del_struct_record (\fBcar\fP * p, int * len_struct)"

.PP
Удаление полей записи в массиве структур 
.SS "void del_struct_record_menu ()"

.PP
Вывод меню при выборе удаления полей структуры 
.SS "int del_struct_search (\fBcar\fP * p, \fBBUFER\fP buf, int record)"

.PP
Функция поиска совпадений в полях структуры при удалении 
.SS "void ident_buf (\fBBUFER\fP buf)"

.PP
Идентификация буфера 
.SS "void ident_pos (\fBPOS_PARS\fP pos_pars)"

.PP
Нахождение позиции запятой, для дальнейшего парсинга строки 
.SS "void ident_struct (\fBcar\fP * p)"

.PP
Идентификайия структуры для дальнейшего заполнения 
.SS "int main ()"

.SS "int menu (\fBcar\fP * p, \fBcar\fP * p_not, \fBcar_sort\fP * s, \fBcar_sort\fP * o, int * len_struct)"

.PP
Меню 
.SS "int parser (\fBcar\fP * p, \fBcar_sort\fP * s, \fBBUFER\fP buf)"

.PP
Парсинг строк из файла 
.SS "void print_len (\fBcar\fP * p, short * len_model, short * len_country, short * len_color, short * len_cost, int len_struct)"

.SS "void print_result (clock_t shell1, clock_t shell2, clock_t bubble1, clock_t bubble2, clock_t shell3, clock_t shell4, clock_t bubble3, clock_t bubble4)"

.PP
Печать времени сортировок массива структур и массива ключей 
.SS "void print_struct (\fBcar\fP * p, int len_struct)"

.PP
Печать таблицы данных 
.SS "void print_struct_sort (\fBcar\fP * p, \fBcar_sort\fP * s, int len_struct)"

.PP
Печать таблицы, содержащий поля массива структур 
.SS "void printf_result_sort (\fBcar\fP * p, \fBcar_sort\fP * p_s, int len_struct)"

.PP
Печать ключей 
.SS "void sort_dont_key_bubble (\fBcar\fP * p, int len_struct)"

.PP
Сортировка массива структур методом пузырька 
.SS "void sort_dont_key_quick (\fBcar\fP * p, int len_struct)"

.PP
Сортировка массива структур методом Шелла 
.SS "void sort_struct_bubble (\fBcar_sort\fP * s, int len_struct)"

.PP
Сортировка структуры ключей методом пузырька 
.SS "void sort_struct_quick (\fBcar_sort\fP * s, int len_struct)"

.PP
Сортировка структуры ключей методом Шелла 
.SH "Автор"
.PP 
Автоматически создано Doxygen для lab_02_doxygen из исходного текста\&.
